/* File: symgrouplibmodule.c
 * This file is auto-generated with f2py (version:2.1.1).
 * f2py is a Fortran to Python Interface Generator (FPIG), Second Edition,
 * written by Pearu Peterson <pearu@cens.ioc.ee>.
 * Generation date: Fri Sep 27 18:45:02 2024
 * Do not edit this file directly unless you know what you are doing!!!
 */

#ifdef __cplusplus
extern "C" {
#endif

#ifndef PY_SSIZE_T_CLEAN
#define PY_SSIZE_T_CLEAN
#endif /* PY_SSIZE_T_CLEAN */

/* Unconditionally included */
#include <Python.h>
#include <numpy/npy_os.h>

/*********************** See f2py2e/cfuncs.py: includes ***********************/
#include "fortranobject.h"
#include <string.h>
#include <math.h>

/**************** See f2py2e/rules.py: mod_rules['modulebody'] ****************/
static PyObject *symgrouplib_error;
static PyObject *symgrouplib_module;

/*********************** See f2py2e/cfuncs.py: typedefs ***********************/
typedef char * string;

/****************** See f2py2e/cfuncs.py: typedefs_generated ******************/
/*need_typedefs_generated*/

/********************** See f2py2e/cfuncs.py: cppmacros **********************/
#define DEBUGCFUNCS
#define FAILNULL(p) do {                                            \
    if ((p) == NULL) {                                              \
        PyErr_SetString(PyExc_MemoryError, "NULL pointer found");   \
        goto capi_fail;                                             \
    }                                                               \
} while (0)


#define STRINGMALLOC(str,len)\
    if ((str = (string)malloc(len+1)) == NULL) {\
        PyErr_SetString(PyExc_MemoryError, "out of memory");\
        goto capi_fail;\
    } else {\
        (str)[len] = '\0';\
    }


#if defined(PREPEND_FORTRAN)
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F
#else
#define F_FUNC(f,F) _##f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F##_
#else
#define F_FUNC(f,F) _##f##_
#endif
#endif
#else
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F
#else
#define F_FUNC(f,F) f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F##_
#else
#define F_FUNC(f,F) f##_
#endif
#endif
#endif
#if defined(UNDERSCORE_G77)
#define F_FUNC_US(f,F) F_FUNC(f##_,F##_)
#else
#define F_FUNC_US(f,F) F_FUNC(f,F)
#endif


/* See fortranobject.h for definitions. The macros here are provided for BC. */
#define rank f2py_rank
#define shape f2py_shape
#define fshape f2py_shape
#define len f2py_len
#define flen f2py_flen
#define slen f2py_slen
#define size f2py_size


#define STRINGFREE(str) do {if (!(str == NULL)) free(str);} while (0)


/*
STRINGPADN replaces null values with padding values from the right.

`to` must have size of at least N bytes.

If the `to[N-1]` has null value, then replace it and all the
preceding, nulls with the given padding.

STRINGPADN(to, N, PADDING, NULLVALUE) is an inverse operation.
*/
#define STRINGPADN(to, N, NULLVALUE, PADDING)                   \
    do {                                                        \
        int _m = (N);                                           \
        char *_to = (to);                                       \
        for (_m -= 1; _m >= 0 && _to[_m] == NULLVALUE; _m--) {  \
             _to[_m] = PADDING;                                 \
        }                                                       \
    } while (0)


#ifdef DEBUGCFUNCS
#define CFUNCSMESS(mess) fprintf(stderr,"debug-capi:"mess);
#define CFUNCSMESSPY(mess,obj) CFUNCSMESS(mess) \
//    PyObject_Print((PyObject *)obj,stderr,Py_PRINT_RAW);\
//    fprintf(stderr,"\n");
#else
#define CFUNCSMESS(mess)
#define CFUNCSMESSPY(mess,obj)
#endif


#ifndef max
#define max(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef min
#define min(a,b) ((a < b) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef MIN
#define MIN(a,b) ((a < b) ? (a) : (b))
#endif


/*
STRINGCOPYN copies N bytes.

`to` and `from` buffers must have sizes of at least N bytes.
*/
#define STRINGCOPYN(to,from,N)                                  \
    do {                                                        \
        int _m = (N);                                           \
        char *_to = (to);                                       \
        char *_from = (from);                                   \
        FAILNULL(_to); FAILNULL(_from);                         \
        (void)strncpy(_to, _from, _m);             \
    } while (0)


/************************ See f2py2e/cfuncs.py: cfuncs ************************/

static int
int_from_pyobj(int* v, PyObject *obj, const char *errmess)
{
    PyObject* tmp = NULL;

    if (PyLong_Check(obj)) {
        *v = Npy__PyLong_AsInt(obj);
        return !(*v == -1 && PyErr_Occurred());
    }

    tmp = PyNumber_Long(obj);
    if (tmp) {
        *v = Npy__PyLong_AsInt(tmp);
        Py_DECREF(tmp);
        return !(*v == -1 && PyErr_Occurred());
    }

    if (PyComplex_Check(obj)) {
        PyErr_Clear();
        tmp = PyObject_GetAttrString(obj,"real");
    }
    else if (PyBytes_Check(obj) || PyUnicode_Check(obj)) {
        /*pass*/;
    }
    else if (PySequence_Check(obj)) {
        PyErr_Clear();
        tmp = PySequence_GetItem(obj, 0);
    }

    if (tmp) {
        if (int_from_pyobj(v, tmp, errmess)) {
            Py_DECREF(tmp);
            return 1;
        }
        Py_DECREF(tmp);
    }

    {
        PyObject* err = PyErr_Occurred();
        if (err == NULL) {
            err = symgrouplib_error;
        }
        PyErr_SetString(err, errmess);
    }
    return 0;
}


/*
  Create a new string buffer `str` of at most length `len` from a
  Python string-like object `obj`.

  The string buffer has given size (len) or the size of inistr when len==-1.

  The string buffer is padded with blanks: in Fortran, trailing blanks
  are insignificant contrary to C nulls.
 */
static int
string_from_pyobj(string *str, int *len, const string inistr, PyObject *obj,
                  const char *errmess)
{
    PyObject *tmp = NULL;
    string buf = NULL;
    npy_intp n = -1;
#ifdef DEBUGCFUNCS
#endif
    if (obj == Py_None) {
        n = strlen(inistr);
        buf = inistr;
    }
    else if (PyArray_Check(obj)) {
        PyArrayObject *arr = (PyArrayObject *)obj;
        if (!ISCONTIGUOUS(arr)) {
            PyErr_SetString(PyExc_ValueError,
                            "array object is non-contiguous.");
            goto capi_fail;
        }
        n = PyArray_NBYTES(arr);
        buf = PyArray_DATA(arr);
        n = strnlen(buf, n);
    }
    else {
        if (PyBytes_Check(obj)) {
            tmp = obj;
            Py_INCREF(tmp);
        }
        else if (PyUnicode_Check(obj)) {
            tmp = PyUnicode_AsASCIIString(obj);
        }
        else {
            PyObject *tmp2;
            tmp2 = PyObject_Str(obj);
            if (tmp2) {
                tmp = PyUnicode_AsASCIIString(tmp2);
                Py_DECREF(tmp2);
            }
            else {
                tmp = NULL;
            }
        }
        if (tmp == NULL) goto capi_fail;
        n = PyBytes_GET_SIZE(tmp);
        buf = PyBytes_AS_STRING(tmp);
    }
    if (*len == -1) {
        /* TODO: change the type of `len` so that we can remove this */
        if (n > NPY_MAX_INT) {
            PyErr_SetString(PyExc_OverflowError,
                            "object too large for a 32-bit int");
            goto capi_fail;
        }
        *len = n;
    }
    else if (*len < n) {
        /* discard the last (len-n) bytes of input buf */
        n = *len;
    }
    if (n < 0 || *len < 0 || buf == NULL) {
        goto capi_fail;
    }
    STRINGMALLOC(*str, *len);  // *str is allocated with size (*len + 1)
    if (n < *len) {
        /*
          Pad fixed-width string with nulls. The caller will replace
          nulls with blanks when the corresponding argument is not
          intent(c).
        */
        memset(*str + n, '\0', *len - n);
    }
    STRINGCOPYN(*str, buf, n);
    Py_XDECREF(tmp);
    return 1;
capi_fail:
    Py_XDECREF(tmp);
    {
        PyObject* err = PyErr_Occurred();
        if (err == NULL) {
            err = symgrouplib_error;
        }
        PyErr_SetString(err, errmess);
    }
    return 0;
}


static int
double_from_pyobj(double* v, PyObject *obj, const char *errmess)
{
    PyObject* tmp = NULL;
    if (PyFloat_Check(obj)) {
        *v = PyFloat_AsDouble(obj);
        return !(*v == -1.0 && PyErr_Occurred());
    }

    tmp = PyNumber_Float(obj);
    if (tmp) {
        *v = PyFloat_AsDouble(tmp);
        Py_DECREF(tmp);
        return !(*v == -1.0 && PyErr_Occurred());
    }

    if (PyComplex_Check(obj)) {
        PyErr_Clear();
        tmp = PyObject_GetAttrString(obj,"real");
    }
    else if (PyBytes_Check(obj) || PyUnicode_Check(obj)) {
        /*pass*/;
    }
    else if (PySequence_Check(obj)) {
        PyErr_Clear();
        tmp = PySequence_GetItem(obj, 0);
    }

    if (tmp) {
        if (double_from_pyobj(v,tmp,errmess)) {Py_DECREF(tmp); return 1;}
        Py_DECREF(tmp);
    }
    {
        PyObject* err = PyErr_Occurred();
        if (err==NULL) err = symgrouplib_error;
        PyErr_SetString(err,errmess);
    }
    return 0;
}


/********************* See f2py2e/cfuncs.py: userincludes *********************/
/*need_userincludes*/

/********************* See f2py2e/capi_rules.py: usercode *********************/


/* See f2py2e/rules.py */
extern void F_FUNC(symgroup,SYMGROUP)(double*,int*,string*,int*,string,int*,int*,double*,int*,double*,double*,int*,int*,int*,double*,double*,double*,int*,double*,double*,double*,size_t,size_t);
/*eof externroutines*/

/******************** See f2py2e/capi_rules.py: usercode1 ********************/


/******************* See f2py2e/cb_rules.py: buildcallback *******************/
/*need_callbacks*/

/*********************** See f2py2e/rules.py: buildapi ***********************/

/********************************** symgroup **********************************/
static char doc_f2py_rout_symgrouplib_symgroup[] = "\
s_max,NearStruc,vmax,optper,refAxis,sm,vm = symgroup(coordinates,multi,labels,central_atom,oper,oeix,centerfix,center,conntype,vcon,thresh,fixpermu,permu)\n\nWrapper for ``symgroup``.\
\n\nParameters\n----------\n"
"coordinates : input rank-2 array('d') with bounds (nat,3)\n"
"multi : input int\n"
"labels : input rank-1 array('S') with bounds (nat)\n"
"central_atom : input int\n"
"oper : input string(len=1)\n"
"oeix : input int\n"
"centerfix : input int\n"
"center : input rank-1 array('d') with bounds (3)\n"
"conntype : input int\n"
"vcon : input rank-1 array('d') with bounds ((nat + nat * nat) / 2)\n"
"thresh : input float\n"
"fixpermu : input int\n"
"permu : input rank-1 array('i') with bounds (nat)\n"
"\nReturns\n-------\n"
"s_max : float\n"
"NearStruc : rank-2 array('d') with bounds (nat,3)\n"
"vmax : rank-1 array('d') with bounds (3)\n"
"optper : rank-1 array('i') with bounds (nat)\n"
"refAxis : rank-2 array('d') with bounds (4,3)\n"
"sm : rank-1 array('d') with bounds (20)\n"
"vm : rank-2 array('d') with bounds (20,3)";
/* extern void F_FUNC(symgroup,SYMGROUP)(double*,int*,string*,int*,string,int*,int*,double*,int*,double*,double*,int*,int*,int*,double*,double*,double*,int*,double*,double*,double*,size_t,size_t); */
static PyObject *f2py_rout_symgrouplib_symgroup(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,string*,int*,string,int*,int*,double*,int*,double*,double*,int*,int*,int*,double*,double*,double*,int*,double*,double*,double*,size_t,size_t)) {
    PyObject * volatile capi_buildvalue = NULL;
    volatile int f2py_success = 1;
/*decl*/

    double *coordinates = NULL;
    npy_intp coordinates_Dims[2] = {-1, -1};
    const int coordinates_Rank = 2;
    PyArrayObject *capi_coordinates_as_array = NULL;
    int capi_coordinates_intent = 0;
    PyObject *coordinates_capi = Py_None;
    int multi = 0;
    PyObject *multi_capi = Py_None;
    string *labels = NULL;
    npy_intp labels_Dims[1] = {-1};
    const int labels_Rank = 1;
    PyArrayObject *capi_labels_as_array = NULL;
    int capi_labels_intent = 0;
    int slen(labels) = 0;
    PyObject *labels_capi = Py_None;
    int central_atom = 0;
    PyObject *central_atom_capi = Py_None;
    string oper = NULL;
    int slen(oper);
    PyObject *oper_capi = Py_None;
    int oeix = 0;
    PyObject *oeix_capi = Py_None;
    int centerfix = 0;
    PyObject *centerfix_capi = Py_None;
    double *center = NULL;
    npy_intp center_Dims[1] = {-1};
    const int center_Rank = 1;
    PyArrayObject *capi_center_as_array = NULL;
    int capi_center_intent = 0;
    PyObject *center_capi = Py_None;
    int conntype = 0;
    PyObject *conntype_capi = Py_None;
    double *vcon = NULL;
    npy_intp vcon_Dims[1] = {-1};
    const int vcon_Rank = 1;
    PyArrayObject *capi_vcon_as_array = NULL;
    int capi_vcon_intent = 0;
    PyObject *vcon_capi = Py_None;
    double thresh = 0;
    PyObject *thresh_capi = Py_None;
    int fixpermu = 0;
    PyObject *fixpermu_capi = Py_None;
    int *permu = NULL;
    npy_intp permu_Dims[1] = {-1};
    const int permu_Rank = 1;
    PyArrayObject *capi_permu_as_array = NULL;
    int capi_permu_intent = 0;
    PyObject *permu_capi = Py_None;
    int nat = 0;
    double s_max = 0;
    double *NearStruc = NULL;
    npy_intp NearStruc_Dims[2] = {-1, -1};
    const int NearStruc_Rank = 2;
    PyArrayObject *capi_NearStruc_as_array = NULL;
    int capi_NearStruc_intent = 0;
    double *vmax = NULL;
    npy_intp vmax_Dims[1] = {-1};
    const int vmax_Rank = 1;
    PyArrayObject *capi_vmax_as_array = NULL;
    int capi_vmax_intent = 0;
    int *optper = NULL;
    npy_intp optper_Dims[1] = {-1};
    const int optper_Rank = 1;
    PyArrayObject *capi_optper_as_array = NULL;
    int capi_optper_intent = 0;
    double *refAxis = NULL;
    npy_intp refAxis_Dims[2] = {-1, -1};
    const int refAxis_Rank = 2;
    PyArrayObject *capi_refAxis_as_array = NULL;
    int capi_refAxis_intent = 0;
    double *sm = NULL;
    npy_intp sm_Dims[1] = {-1};
    const int sm_Rank = 1;
    PyArrayObject *capi_sm_as_array = NULL;
    int capi_sm_intent = 0;
    double *vm = NULL;
    npy_intp vm_Dims[2] = {-1, -1};
    const int vm_Rank = 2;
    PyArrayObject *capi_vm_as_array = NULL;
    int capi_vm_intent = 0;
    static char *capi_kwlist[] = {"coordinates","multi","labels","central_atom","oper","oeix","centerfix","center","conntype","vcon","thresh","fixpermu","permu",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
        "OOOOOOOOOOOOO|:symgrouplib.symgroup",\
        capi_kwlist,&coordinates_capi,&multi_capi,&labels_capi,&central_atom_capi,&oper_capi,&oeix_capi,&centerfix_capi,&center_capi,&conntype_capi,&vcon_capi,&thresh_capi,&fixpermu_capi,&permu_capi))
        return NULL;
/*frompyobj*/
    /* Processing variable coordinates */
    coordinates_Dims[1]=3;
    capi_coordinates_intent |= F2PY_INTENT_IN;
    const char * capi_errmess = "symgrouplib.symgrouplib.symgroup: failed to create array from the 1st argument `coordinates`";
    capi_coordinates_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,coordinates_Dims,coordinates_Rank,  capi_coordinates_intent,coordinates_capi,capi_errmess);
    if (capi_coordinates_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = symgrouplib_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        coordinates = (double *)(PyArray_DATA(capi_coordinates_as_array));

    /* Processing variable multi */
        f2py_success = int_from_pyobj(&multi,multi_capi,"symgrouplib.symgroup() 2nd argument (multi) can't be converted to int");
    if (f2py_success) {
    /* Processing variable oeix */
        f2py_success = int_from_pyobj(&oeix,oeix_capi,"symgrouplib.symgroup() 6th argument (oeix) can't be converted to int");
    if (f2py_success) {
    /* Processing variable central_atom */
        f2py_success = int_from_pyobj(&central_atom,central_atom_capi,"symgrouplib.symgroup() 4th argument (central_atom) can't be converted to int");
    if (f2py_success) {
    /* Processing variable oper */
    slen(oper) = 1;
    f2py_success = string_from_pyobj(&oper,&slen(oper),"",oper_capi,"string_from_pyobj failed in converting 5th argument`oper' of symgrouplib.symgroup to C string");
    if (f2py_success) {
        STRINGPADN(oper, slen(oper), '\0', ' ');
    /* Processing variable centerfix */
        centerfix = (int)PyObject_IsTrue(centerfix_capi);
        f2py_success = 1;
    if (f2py_success) {
    /* Processing variable conntype */
        f2py_success = int_from_pyobj(&conntype,conntype_capi,"symgrouplib.symgroup() 9th argument (conntype) can't be converted to int");
    if (f2py_success) {
    /* Processing variable center */
    center_Dims[0]=3;
    capi_center_intent |= F2PY_INTENT_IN;
    const char * capi_errmess = "symgrouplib.symgrouplib.symgroup: failed to create array from the 8th argument `center`";
    capi_center_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,center_Dims,center_Rank,  capi_center_intent,center_capi,capi_errmess);
    if (capi_center_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = symgrouplib_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        center = (double *)(PyArray_DATA(capi_center_as_array));

    /* Processing variable thresh */
        f2py_success = double_from_pyobj(&thresh,thresh_capi,"symgrouplib.symgroup() 11st argument (thresh) can't be converted to double");
    if (f2py_success) {
    /* Processing variable fixpermu */
        fixpermu = (int)PyObject_IsTrue(fixpermu_capi);
        f2py_success = 1;
    if (f2py_success) {
    /* Processing variable s_max */
    /* Processing variable vmax */
    vmax_Dims[0]=3;
    capi_vmax_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
    const char * capi_errmess = "symgrouplib.symgrouplib.symgroup: failed to create array from the hidden `vmax`";
    capi_vmax_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,vmax_Dims,vmax_Rank,  capi_vmax_intent,Py_None,capi_errmess);
    if (capi_vmax_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = symgrouplib_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        vmax = (double *)(PyArray_DATA(capi_vmax_as_array));

    /* Processing variable refAxis */
    refAxis_Dims[0]=4,refAxis_Dims[1]=3;
    capi_refAxis_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
    const char * capi_errmess = "symgrouplib.symgrouplib.symgroup: failed to create array from the hidden `refAxis`";
    capi_refAxis_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,refAxis_Dims,refAxis_Rank,  capi_refAxis_intent,Py_None,capi_errmess);
    if (capi_refAxis_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = symgrouplib_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        refAxis = (double *)(PyArray_DATA(capi_refAxis_as_array));

    /* Processing variable sm */
    sm_Dims[0]=20;
    capi_sm_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
    const char * capi_errmess = "symgrouplib.symgrouplib.symgroup: failed to create array from the hidden `sm`";
    capi_sm_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,sm_Dims,sm_Rank,  capi_sm_intent,Py_None,capi_errmess);
    if (capi_sm_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = symgrouplib_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        sm = (double *)(PyArray_DATA(capi_sm_as_array));

    /* Processing variable vm */
    vm_Dims[0]=20,vm_Dims[1]=3;
    capi_vm_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
    const char * capi_errmess = "symgrouplib.symgrouplib.symgroup: failed to create array from the hidden `vm`";
    capi_vm_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,vm_Dims,vm_Rank,  capi_vm_intent,Py_None,capi_errmess);
    if (capi_vm_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = symgrouplib_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        vm = (double *)(PyArray_DATA(capi_vm_as_array));

    /* Processing variable nat */
    nat = shape(coordinates,0);
    /* Processing variable labels */
    labels_Dims[0]=nat;
    capi_labels_intent |= F2PY_INTENT_IN;
    const char * capi_errmess = "symgrouplib.symgrouplib.symgroup: failed to create array from the 3rd argument `labels`";
    capi_labels_as_array = ndarray_from_pyobj(  NPY_STRING,2,labels_Dims,labels_Rank,  capi_labels_intent,labels_capi,capi_errmess);
    if (capi_labels_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = symgrouplib_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        labels = (string *)(PyArray_DATA(capi_labels_as_array));

    slen(labels) = f2py_itemsize(labels);
    /* Processing variable vcon */
    vcon_Dims[0]=(nat + nat * nat) / 2;
    capi_vcon_intent |= F2PY_INTENT_IN;
    const char * capi_errmess = "symgrouplib.symgrouplib.symgroup: failed to create array from the 10th argument `vcon`";
    capi_vcon_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,vcon_Dims,vcon_Rank,  capi_vcon_intent,vcon_capi,capi_errmess);
    if (capi_vcon_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = symgrouplib_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        vcon = (double *)(PyArray_DATA(capi_vcon_as_array));

    /* Processing variable permu */
    permu_Dims[0]=nat;
    capi_permu_intent |= F2PY_INTENT_IN;
    const char * capi_errmess = "symgrouplib.symgrouplib.symgroup: failed to create array from the 13rd argument `permu`";
    capi_permu_as_array = ndarray_from_pyobj(  NPY_INT,1,permu_Dims,permu_Rank,  capi_permu_intent,permu_capi,capi_errmess);
    if (capi_permu_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = symgrouplib_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        permu = (int *)(PyArray_DATA(capi_permu_as_array));

    /* Processing variable NearStruc */
    NearStruc_Dims[0]=nat,NearStruc_Dims[1]=3;
    capi_NearStruc_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
    const char * capi_errmess = "symgrouplib.symgrouplib.symgroup: failed to create array from the hidden `NearStruc`";
    capi_NearStruc_as_array = ndarray_from_pyobj(  NPY_DOUBLE,1,NearStruc_Dims,NearStruc_Rank,  capi_NearStruc_intent,Py_None,capi_errmess);
    if (capi_NearStruc_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = symgrouplib_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        NearStruc = (double *)(PyArray_DATA(capi_NearStruc_as_array));

    /* Processing variable optper */
    optper_Dims[0]=nat;
    capi_optper_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
    const char * capi_errmess = "symgrouplib.symgrouplib.symgroup: failed to create array from the hidden `optper`";
    capi_optper_as_array = ndarray_from_pyobj(  NPY_INT,1,optper_Dims,optper_Rank,  capi_optper_intent,Py_None,capi_errmess);
    if (capi_optper_as_array == NULL) {
        PyObject* capi_err = PyErr_Occurred();
        if (capi_err == NULL) {
            capi_err = symgrouplib_error;
            PyErr_SetString(capi_err, capi_errmess);
        }
    } else {
        optper = (int *)(PyArray_DATA(capi_optper_as_array));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
                (*f2py_func)(coordinates,&multi,labels,&central_atom,oper,&oeix,&centerfix,center,&conntype,vcon,&thresh,&fixpermu,permu,&nat,&s_max,NearStruc,vmax,optper,refAxis,sm,vm,slen(labels),slen(oper));
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
        if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
        capi_buildvalue = Py_BuildValue("dNNNNNN",s_max,capi_NearStruc_as_array,capi_vmax_as_array,capi_optper_as_array,capi_refAxis_as_array,capi_sm_as_array,capi_vm_as_array);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
        } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
    }  /* if (capi_optper_as_array == NULL) ... else of optper */
    /* End of cleaning variable optper */
    }  /* if (capi_NearStruc_as_array == NULL) ... else of NearStruc */
    /* End of cleaning variable NearStruc */
    if((PyObject *)capi_permu_as_array!=permu_capi) {
        Py_XDECREF(capi_permu_as_array); }
    }  /* if (capi_permu_as_array == NULL) ... else of permu */
    /* End of cleaning variable permu */
    if((PyObject *)capi_vcon_as_array!=vcon_capi) {
        Py_XDECREF(capi_vcon_as_array); }
    }  /* if (capi_vcon_as_array == NULL) ... else of vcon */
    /* End of cleaning variable vcon */
    if((PyObject *)capi_labels_as_array!=labels_capi) {
        Py_XDECREF(capi_labels_as_array); }
    }  /* if (capi_labels_as_array == NULL) ... else of labels */
    /* End of cleaning variable labels */
    /* End of cleaning variable nat */
    }  /* if (capi_vm_as_array == NULL) ... else of vm */
    /* End of cleaning variable vm */
    }  /* if (capi_sm_as_array == NULL) ... else of sm */
    /* End of cleaning variable sm */
    }  /* if (capi_refAxis_as_array == NULL) ... else of refAxis */
    /* End of cleaning variable refAxis */
    }  /* if (capi_vmax_as_array == NULL) ... else of vmax */
    /* End of cleaning variable vmax */
    /* End of cleaning variable s_max */
    } /*if (f2py_success) of fixpermu*/
    /* End of cleaning variable fixpermu */
    } /*if (f2py_success) of thresh*/
    /* End of cleaning variable thresh */
    if((PyObject *)capi_center_as_array!=center_capi) {
        Py_XDECREF(capi_center_as_array); }
    }  /* if (capi_center_as_array == NULL) ... else of center */
    /* End of cleaning variable center */
    } /*if (f2py_success) of conntype*/
    /* End of cleaning variable conntype */
    } /*if (f2py_success) of centerfix*/
    /* End of cleaning variable centerfix */
        STRINGFREE(oper);
    }  /*if (f2py_success) of oper*/
    /* End of cleaning variable oper */
    } /*if (f2py_success) of central_atom*/
    /* End of cleaning variable central_atom */
    } /*if (f2py_success) of oeix*/
    /* End of cleaning variable oeix */
    } /*if (f2py_success) of multi*/
    /* End of cleaning variable multi */
    if((PyObject *)capi_coordinates_as_array!=coordinates_capi) {
        Py_XDECREF(capi_coordinates_as_array); }
    }  /* if (capi_coordinates_as_array == NULL) ... else of coordinates */
    /* End of cleaning variable coordinates */
/*end of cleanupfrompyobj*/
    if (capi_buildvalue == NULL) {
/*routdebugfailure*/
    } else {
/*routdebugleave*/
    }
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
    return capi_buildvalue;
}
/****************************** end of symgroup ******************************/
/*eof body*/

/******************* See f2py2e/f90mod_rules.py: buildhooks *******************/
/*need_f90modhooks*/

/************** See f2py2e/rules.py: module_rules['modulebody'] **************/

/******************* See f2py2e/common_rules.py: buildhooks *******************/

/*need_commonhooks*/

/**************************** See f2py2e/rules.py ****************************/

static FortranDataDef f2py_routine_defs[] = {
    {"symgroup",-1,{{-1}},0,0,(char *)  F_FUNC(symgroup,SYMGROUP),  (f2py_init_func)f2py_rout_symgrouplib_symgroup,doc_f2py_rout_symgrouplib_symgroup},

/*eof routine_defs*/
    {NULL}
};

static PyMethodDef f2py_module_methods[] = {

    {NULL,NULL}
};

static struct PyModuleDef moduledef = {
    PyModuleDef_HEAD_INIT,
    "symgrouplib",
    NULL,
    -1,
    f2py_module_methods,
    NULL,
    NULL,
    NULL,
    NULL
};

PyMODINIT_FUNC PyInit_symgrouplib(void) {
    int i;
    PyObject *m,*d, *s, *tmp;
    m = symgrouplib_module = PyModule_Create(&moduledef);
    Py_SET_TYPE(&PyFortran_Type, &PyType_Type);
    import_array();
    if (PyErr_Occurred())
        {PyErr_SetString(PyExc_ImportError, "can't initialize module symgrouplib (failed to import numpy)"); return m;}
    d = PyModule_GetDict(m);
    s = PyUnicode_FromString("2.1.1");
    PyDict_SetItemString(d, "__version__", s);
    Py_DECREF(s);
    s = PyUnicode_FromString(
        "This module 'symgrouplib' is auto-generated with f2py (version:2.1.1).\nFunctions:\n"
"    s_max,NearStruc,vmax,optper,refAxis,sm,vm = symgroup(coordinates,multi,labels,central_atom,oper,oeix,centerfix,center,conntype,vcon,thresh,fixpermu,permu)\n"
".");
    PyDict_SetItemString(d, "__doc__", s);
    Py_DECREF(s);
    s = PyUnicode_FromString("2.1.1");
    PyDict_SetItemString(d, "__f2py_numpy_version__", s);
    Py_DECREF(s);
    symgrouplib_error = PyErr_NewException ("symgrouplib.error", NULL, NULL);
    /*
     * Store the error object inside the dict, so that it could get deallocated.
     * (in practice, this is a module, so it likely will not and cannot.)
     */
    PyDict_SetItemString(d, "_symgrouplib_error", symgrouplib_error);
    Py_DECREF(symgrouplib_error);
    for(i=0;f2py_routine_defs[i].name!=NULL;i++) {
        tmp = PyFortranObject_NewAsAttr(&f2py_routine_defs[i]);
        PyDict_SetItemString(d, f2py_routine_defs[i].name, tmp);
        Py_DECREF(tmp);
    }

/*eof initf2pywraphooks*/
/*eof initf90modhooks*/

/*eof initcommonhooks*/


#if Py_GIL_DISABLED
    // signal whether this module supports running with the GIL disabled
    PyUnstable_Module_SetGIL(m , Py_MOD_GIL_USED);
#endif

#ifdef F2PY_REPORT_ATEXIT
    if (! PyErr_Occurred())
        on_exit(f2py_report_on_exit,(void*)"symgrouplib");
#endif
    return m;
}
#ifdef __cplusplus
}
#endif
